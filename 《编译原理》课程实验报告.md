<br></br>
<br></br>

# <center>《编译原理》课程实验报告</center>
<br></br>
<br></br>

#### **<center>专业年级:<u>网络空间安全2018级</u></center>**
#### **<center>姓名：<u>&emsp;&emsp;&emsp;薛铖勇&emsp;&emsp;&emsp;&emsp;</u></center>**
#### **<center>学号：<u>&emsp;&emsp;2018302180080&emsp;</u></center>**
#### **<center>姓名：<u>&emsp;&emsp;&emsp;&emsp;罗鉴&emsp;&emsp;&emsp;&emsp;</u></center>**
#### **<center>学号：<u>&emsp;&emsp;2018302180054&emsp;</u></center>**
<br>

#### **<center>填写时间：<u>&emsp;&emsp;2020.5.24&emsp;&emsp;</u></center>**

<div STYLE="page-break-after: always;"></div>

## 1. 文法描述

> 要求：给出所实现的语言的文法描述，语义规则描述 

### 文法描述

Tiny+语言的文法描述如下:

>program -> declaration-list; stmt-sequence
declaration-list → declaration-list declaration | declaration
declaration → type-specifier **identifier**;
type-specifier → **int** | **char**
stmt-sequence -> stmt-sequence; statement | statement
statement -> if-stmt | repeat-stmt | assign-stmt | read-stmt | write-stmt
if-stmt -> **if** (exp) **then** stmt-sequence **end** | **if** (exp) **then** stmt-sequence **else** stmt-sequence **end**
repeat-stmt -> **repeat** stmt-sequence **until** exp
assign-stmt -> **identifier** := exp
read-stmt -> read **identifier**
write-stmt -> **write** exp
exp -> simple-exp comparson-op simple-exp | simple-exp
comparison -> < | =
simple-exp -> simple-exp addop term | term
addop -> + | -
term -> term mulop factor | factor
mulop -> * | /
factor -> (exp) | **number** | **identifier**
number -> (+|-)?[1-9][0-9]*
identifier -> [a-zA-Z]([0-9]| [a-zA-Z])*

### 语义规则描述

## 2. 程序框架

> 要求：结合源代码对程序框架进行说明

### global.h

定义了整个编译器运行阶段中重要的常量，包括保留符数量 `MAXRESERVED`、token的种类 `TokenType`、语法树节点 `NodeKind`、语法树结构体 `TreeNode`等等

### main.c

整个编译器的主函数，总体流程框架在该模块内编写。主要的流程是：
* 对命令行操作进行校验，确保目标文件存在
* 词法分析
* 语法分析
* 语义分析
* 中间代码生成
然后在各个模块调用各个模块相应的代码，获取最终的编译结果

### scan.c

scan.c是整个编译器的词法分析模块，主要负责扫描源程序文本，识别token并保存，服务下一步语法分析的工作

整个scan.c模块大体分为以下三部分：

* **词法分析常量定义**：对后续词法分析程序处理中的一些关键步骤需要的常量和变量进行定义和声明。主要包括：DFA的各状态 `StateType`、当前token的字符序列 `tokenString[MAXTOKENLEN+1]`、保存当前行文本的变量 `lineBuf[BUFLEN]`等
* **词法分析工具函数**：主要包括获取当前行的下一个token的函数 `getNextChar(void)` 和回溯token函数 `ungetNextChar(void)` ，这两个函数在整体的词法分析中是最基础的动作，以及保证变量不与保留符冲突的函数 `reservedLookup (char * s)`
* **词法分析主要过程代码**：这部分就是词法分析的主体函数 `getToken(void)`，通过这个函数能够从源程序中获取一个token。该函数的主要思路是利用DFA来识别不同类的token类型，最外层的while循环让识别字符不断进行直至DFA状态为DONE，然后循环体内多个swicth语句根据读取字符的当前条件进入到不同的DFA状态完成状态转换动作，最终得到该token类型并返回

### parse.c

parse.c是整个编译器的语法分析模块，负责将获得的token序列按照文法组织成语法树以服务下一部分语义分析的进行

整个parse.c模块分为以下部分：
* **语法分析常量定义**：这部分主要定义语法分析部分一些重要的常量，主要是各类型的语法树节点 `TreeNode`
* **语法分析工具函数**：这部分主要是语法分析过程中的一些工具函数，为语法分析整个过程提供支撑，包括语法错误的报错函数 `syntaxError(char * message)`，匹配特定类型token的函数 `match(TokenType expected)`
* **语法分析文法识别**：这部分主要是识别各个种类的语法节点的函数，每个函数都与文法中每个非终结符相对应来识别特定的语法节点。整体的语法分析方法是自上而下的递归下降分析法（从最顶层的 `program` 到最底层的非终结符识别完毕），语法分析结束后，该函数最终返回分析完成的语法树以便于下一部分工作的开展。可以注意到前期的文法设计已经避免了可能出现的问题：即二义性文法、左递归、回溯等

### until.c

until.c包含了一些编译器调试和运行中的重要工具函数，为编译器的调试做辅助。具体包含了打印词法分析结果的 `printToken( TokenType token, const char* tokenString )` 函数、新建语法树节点的 `newDeclarationNode(DecKind kind)` 等、复制字符串的 `copyString(char * s)` 函数以及打印语法树的函数 `printTree( TreeNode * tree )` 等等




## 3. 测试案例与结果

> 要求：根据语言特性，给出测试案例及相关测试结果截屏

## 4. 提交内容说明

### 4.1 源程序运行环境说明

源程序在linux系统下进行编译开发和测试运行

具体系统型号为：Ubuntu16.04

编译器为：GCC

未使用第三方依赖，所有依赖均为C语言库函数

### 4.1 程序运行操作说明

提交的文件中包含了linux平台下的可执行文件 `tiny`，可直接执行：

`./tiny 目标文件.tny`

来进行编译，然后执行

`./tm 生成的目标文件.tm`

如果需要重新生成目标文件，使用makefile即可：

`make clean`

`make all`

即可编译再次生成可执行文件 `tiny`

## 5.实验小结

> 要求：包括但不限：两人的分工；一些心得，等等

### 分工

**薛铖勇**：主要负责编译器设计的词法分析、语法分析部分、编译器工具方法部分的实现以及对整体编译过程常量的修改增添，扩展了tiny语言的语法为tiny+，并增添了若干个新特性。

**罗鉴**：

### 心得

**薛铖勇**：

